package wordprocessingml

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"testing"
	"time"
)

// TestNewFileEmbedder 测试创建文件嵌入器
func TestNewFileEmbedder(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	if embedder == nil {
		t.Fatal("文件嵌入器创建失败")
	}
	
	// 验证默认配置
	if embedder.config.MaxFileSize != 100*1024*1024 { // 100MB
		t.Errorf("默认最大文件大小不匹配，期望: 100MB, 实际: %d", embedder.config.MaxFileSize)
	}
	
	if !embedder.config.CompressionEnabled {
		t.Error("默认应该启用压缩")
	}
	
	if embedder.config.AllowedTypes == nil {
		t.Error("默认允许类型应该被初始化")
	}
}

// TestNewFileEmbedderWithConfig 测试使用配置创建文件嵌入器
func TestNewFileEmbedderWithConfig(t *testing.T) {
	config := &FileEmbedderConfig{
		MaxFileSize:       50 * 1024 * 1024, // 50MB
		CompressionEnabled: false,
		AllowedTypes:      []string{".txt", ".pdf"},
	}
	
	embedder := NewFileEmbedder(config)
	if embedder == nil {
		t.Fatal("文件嵌入器创建失败")
	}
	
	if embedder.config.MaxFileSize != 50*1024*1024 {
		t.Errorf("配置最大文件大小不匹配，期望: 50MB, 实际: %d", embedder.config.MaxFileSize)
	}
	
	if embedder.config.CompressionEnabled {
		t.Error("配置应该禁用压缩")
	}
	
	if len(embedder.config.AllowedTypes) != 2 {
		t.Errorf("配置允许类型数量不匹配，期望: 2, 实际: %d", len(embedder.config.AllowedTypes))
	}
}

// TestEmbedFile 测试嵌入文件
func TestEmbedFile(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	// 创建临时测试文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	testFilePath := filepath.Join(tempDir, "test.txt")
	testContent := "这是一个测试文件内容"
	
	err = os.WriteFile(testFilePath, []byte(testContent), 0644)
	if err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	
	// 测试嵌入文件
	embedInfo := &FileEmbedInfo{
		FilePath:    testFilePath,
		DisplayName: "测试文件.txt",
		Description: "这是一个测试文件",
	}
	
	err = embedder.EmbedFile(ctx, embedInfo)
	if err != nil {
		t.Fatalf("嵌入文件失败: %v", err)
	}
	
	if embedInfo.ID == "" {
		t.Error("嵌入文件ID应该自动生成")
	}
	
	if embedInfo.EmbeddedAt == 0 {
		t.Error("嵌入时间应该设置")
	}
	
	// 验证文件已嵌入
	storedInfo, err := embedder.GetEmbeddedFile(embedInfo.ID)
	if err != nil {
		t.Fatalf("获取嵌入文件失败: %v", err)
	}
	
	if storedInfo.DisplayName != "测试文件.txt" {
		t.Errorf("显示名称不匹配，期望: 测试文件.txt, 实际: %s", storedInfo.DisplayName)
	}
}

// TestEmbedFileWithInvalidPath 测试嵌入无效路径的文件
func TestEmbedFileWithInvalidPath(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	embedInfo := &FileEmbedInfo{
		FilePath:    "/invalid/path/file.txt",
		DisplayName: "无效文件.txt",
	}
	
	err := embedder.EmbedFile(ctx, embedInfo)
	if err == nil {
		t.Error("应该拒绝嵌入无效路径的文件")
	}
}

// TestEmbedFileWithEmptyPath 测试嵌入空路径的文件
func TestEmbedFileWithEmptyPath(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	embedInfo := &FileEmbedInfo{
		FilePath:    "",
		DisplayName: "空路径文件.txt",
	}
	
	err := embedder.EmbedFile(ctx, embedInfo)
	if err == nil {
		t.Error("应该拒绝嵌入空路径的文件")
	}
}

// TestEmbedFileWithLargeFile 测试嵌入大文件
func TestEmbedFileWithLargeFile(t *testing.T) {
	// 创建限制配置
	config := &FileEmbedderConfig{
		MaxFileSize: 1024, // 1KB
	}
	
	embedder := NewFileEmbedder(config)
	ctx := context.Background()
	
	// 创建临时测试文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	testFilePath := filepath.Join(tempDir, "large_test.txt")
	largeContent := make([]byte, 2048) // 2KB
	
	err = os.WriteFile(testFilePath, largeContent, 0644)
	if err != nil {
		t.Fatalf("创建大测试文件失败: %v", err)
	}
	
	embedInfo := &FileEmbedInfo{
		FilePath:    testFilePath,
		DisplayName: "大文件.txt",
	}
	
	err = embedder.EmbedFile(ctx, embedInfo)
	if err == nil {
		t.Error("应该拒绝嵌入超过大小限制的文件")
	}
}

// TestEmbedFileWithUnsupportedType 测试嵌入不支持类型的文件
func TestEmbedFileWithUnsupportedType(t *testing.T) {
	config := &FileEmbedderConfig{
		AllowedTypes: []string{".txt", ".pdf"},
	}
	
	embedder := NewFileEmbedder(config)
	ctx := context.Background()
	
	// 创建临时测试文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	testFilePath := filepath.Join(tempDir, "test.exe")
	testContent := "这是一个可执行文件"
	
	err = os.WriteFile(testFilePath, []byte(testContent), 0644)
	if err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	
	embedInfo := &FileEmbedInfo{
		FilePath:    testFilePath,
		DisplayName: "test.exe",
	}
	
	err = embedder.EmbedFile(ctx, embedInfo)
	if err == nil {
		t.Error("应该拒绝嵌入不支持类型的文件")
	}
}

// TestGetEmbeddedFile 测试获取嵌入文件
func TestGetEmbeddedFile(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	// 先嵌入一个文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	testFilePath := filepath.Join(tempDir, "test.txt")
	testContent := "测试内容"
	
	err = os.WriteFile(testFilePath, []byte(testContent), 0644)
	if err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	
	embedInfo := &FileEmbedInfo{
		FilePath:    testFilePath,
		DisplayName: "测试文件.txt",
	}
	
	err = embedder.EmbedFile(ctx, embedInfo)
	if err != nil {
		t.Fatalf("嵌入文件失败: %v", err)
	}
	
	// 获取嵌入文件
	retrievedInfo, err := embedder.GetEmbeddedFile(embedInfo.ID)
	if err != nil {
		t.Fatalf("获取嵌入文件失败: %v", err)
	}
	
	if retrievedInfo.ID != embedInfo.ID {
		t.Errorf("文件ID不匹配，期望: %s, 实际: %s", embedInfo.ID, retrievedInfo.ID)
	}
	
	if retrievedInfo.DisplayName != embedInfo.DisplayName {
		t.Errorf("显示名称不匹配，期望: %s, 实际: %s", embedInfo.DisplayName, retrievedInfo.DisplayName)
	}
}

// TestGetNonExistentEmbeddedFile 测试获取不存在的嵌入文件
func TestGetNonExistentEmbeddedFile(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	
	_, err := embedder.GetEmbeddedFile("non_existent_id")
	if err == nil {
		t.Error("应该拒绝获取不存在的嵌入文件")
	}
}

// TestListEmbeddedFiles 测试列出嵌入文件
func TestListEmbeddedFiles(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	// 获取初始列表
	initialList := embedder.ListEmbeddedFiles()
	if len(initialList) != 0 {
		t.Errorf("初始嵌入文件列表应该为空，实际: %d", len(initialList))
	}
	
	// 嵌入一些文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	files := []struct {
		path        string
		content     string
		displayName string
	}{
		{filepath.Join(tempDir, "file1.txt"), "文件1内容", "文件1.txt"},
		{filepath.Join(tempDir, "file2.txt"), "文件2内容", "文件2.txt"},
		{filepath.Join(tempDir, "file3.txt"), "文件3内容", "文件3.txt"},
	}
	
	for _, file := range files {
		err = os.WriteFile(file.path, []byte(file.content), 0644)
		if err != nil {
			t.Fatalf("创建测试文件失败: %v", err)
		}
		
		embedInfo := &FileEmbedInfo{
			FilePath:    file.path,
			DisplayName: file.displayName,
		}
		
		err = embedder.EmbedFile(ctx, embedInfo)
		if err != nil {
			t.Fatalf("嵌入文件失败: %v", err)
		}
	}
	
	// 获取更新后的列表
	updatedList := embedder.ListEmbeddedFiles()
	if len(updatedList) != 3 {
		t.Errorf("嵌入文件列表长度不匹配，期望: 3, 实际: %d", len(updatedList))
	}
	
	// 验证文件信息
	fileNames := make(map[string]bool)
	for _, file := range updatedList {
		fileNames[file.DisplayName] = true
	}
	
	expectedNames := []string{"文件1.txt", "文件2.txt", "文件3.txt"}
	for _, expectedName := range expectedNames {
		if !fileNames[expectedName] {
			t.Errorf("嵌入文件列表应该包含: %s", expectedName)
		}
	}
}

// TestRemoveEmbeddedFile 测试移除嵌入文件
func TestRemoveEmbeddedFile(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	// 先嵌入一个文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	testFilePath := filepath.Join(tempDir, "test.txt")
	testContent := "测试内容"
	
	err = os.WriteFile(testFilePath, []byte(testContent), 0644)
	if err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	
	embedInfo := &FileEmbedInfo{
		FilePath:    testFilePath,
		DisplayName: "测试文件.txt",
	}
	
	err = embedder.EmbedFile(ctx, embedInfo)
	if err != nil {
		t.Fatalf("嵌入文件失败: %v", err)
	}
	
	// 移除嵌入文件
	err = embedder.RemoveEmbeddedFile(embedInfo.ID)
	if err != nil {
		t.Fatalf("移除嵌入文件失败: %v", err)
	}
	
	// 验证文件已被移除
	_, err = embedder.GetEmbeddedFile(embedInfo.ID)
	if err == nil {
		t.Error("嵌入文件应该已被移除")
	}
	
	// 验证列表为空
	fileList := embedder.ListEmbeddedFiles()
	if len(fileList) != 0 {
		t.Errorf("嵌入文件列表应该为空，实际: %d", len(fileList))
	}
}

// TestRemoveNonExistentEmbeddedFile 测试移除不存在的嵌入文件
func TestRemoveNonExistentEmbeddedFile(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	
	err := embedder.RemoveEmbeddedFile("non_existent_id")
	if err == nil {
		t.Error("应该拒绝移除不存在的嵌入文件")
	}
}

// TestUpdateEmbeddedFile 测试更新嵌入文件信息
func TestUpdateEmbeddedFile(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	// 先嵌入一个文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	testFilePath := filepath.Join(tempDir, "test.txt")
	testContent := "测试内容"
	
	err = os.WriteFile(testFilePath, []byte(testContent), 0644)
	if err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	
	embedInfo := &FileEmbedInfo{
		FilePath:    testFilePath,
		DisplayName: "原始名称.txt",
		Description: "原始描述",
	}
	
	err = embedder.EmbedFile(ctx, embedInfo)
	if err != nil {
		t.Fatalf("嵌入文件失败: %v", err)
	}
	
	// 更新文件信息
	updateInfo := &FileEmbedInfo{
		DisplayName: "更新后的名称.txt",
		Description: "更新后的描述",
		Tags:        []string{"tag1", "tag2"},
	}
	
	err = embedder.UpdateEmbeddedFile(embedInfo.ID, updateInfo)
	if err != nil {
		t.Fatalf("更新嵌入文件失败: %v", err)
	}
	
	// 验证更新
	updatedInfo, err := embedder.GetEmbeddedFile(embedInfo.ID)
	if err != nil {
		t.Fatalf("获取更新后的嵌入文件失败: %v", err)
	}
	
	if updatedInfo.DisplayName != "更新后的名称.txt" {
		t.Errorf("显示名称应该已更新，期望: 更新后的名称.txt, 实际: %s", updatedInfo.DisplayName)
	}
	
	if updatedInfo.Description != "更新后的描述" {
		t.Errorf("描述应该已更新，期望: 更新后的描述, 实际: %s", updatedInfo.Description)
	}
	
	if len(updatedInfo.Tags) != 2 {
		t.Errorf("标签数量应该已更新，期望: 2, 实际: %d", len(updatedInfo.Tags))
	}
}

// TestUpdateNonExistentEmbeddedFile 测试更新不存在的嵌入文件
func TestUpdateNonExistentEmbeddedFile(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	
	updateInfo := &FileEmbedInfo{
		DisplayName: "新名称.txt",
	}
	
	err := embedder.UpdateEmbeddedFile("non_existent_id", updateInfo)
	if err == nil {
		t.Error("应该拒绝更新不存在的嵌入文件")
	}
}

// TestEmbedFileConcurrency 测试并发嵌入文件
func TestEmbedFileConcurrency(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	// 创建临时目录
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	const numGoroutines = 5
	errors := make(chan error, numGoroutines)
	
	for i := 0; i < numGoroutines; i++ {
		go func(id int) {
			testFilePath := filepath.Join(tempDir, fmt.Sprintf("concurrent_%d.txt", id))
			testContent := fmt.Sprintf("并发测试文件%d内容", id)
			
			err := os.WriteFile(testFilePath, []byte(testContent), 0644)
			if err != nil {
				errors <- err
				return
			}
			
			embedInfo := &FileEmbedInfo{
				FilePath:    testFilePath,
				DisplayName: fmt.Sprintf("并发文件%d.txt", id),
			}
			
			err = embedder.EmbedFile(ctx, embedInfo)
			errors <- err
		}(i)
	}
	
	// 收集错误
	for i := 0; i < numGoroutines; i++ {
		err := <-errors
		if err != nil {
			t.Errorf("并发嵌入文件%d失败: %v", i+1, err)
		}
	}
	
	// 验证所有文件都已嵌入
	fileList := embedder.ListEmbeddedFiles()
	if len(fileList) != numGoroutines {
		t.Errorf("并发嵌入的文件数量不匹配，期望: %d, 实际: %d", numGoroutines, len(fileList))
	}
}

// TestEmbedFileWithCompression 测试压缩嵌入文件
func TestEmbedFileWithCompression(t *testing.T) {
	// 测试启用压缩
	compressedConfig := &FileEmbedderConfig{
		CompressionEnabled: true,
	}
	
	embedder := NewFileEmbedder(compressedConfig)
	ctx := context.Background()
	
	// 创建临时测试文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	testFilePath := filepath.Join(tempDir, "test.txt")
	testContent := "这是一个测试文件内容，包含重复的文本。这是一个测试文件内容，包含重复的文本。"
	
	err = os.WriteFile(testFilePath, []byte(testContent), 0644)
	if err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	
	embedInfo := &FileEmbedInfo{
		FilePath:    testFilePath,
		DisplayName: "压缩测试文件.txt",
	}
	
	err = embedder.EmbedFile(ctx, embedInfo)
	if err != nil {
		t.Fatalf("压缩嵌入文件失败: %v", err)
	}
	
	// 验证文件已嵌入
	if embedInfo.ID == "" {
		t.Error("压缩嵌入文件ID应该自动生成")
	}
}

// TestEmbedFileWithMetadata 测试带元数据的嵌入文件
func TestEmbedFileWithMetadata(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	// 创建临时测试文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	testFilePath := filepath.Join(tempDir, "test.txt")
	testContent := "元数据测试文件内容"
	
	err = os.WriteFile(testFilePath, []byte(testContent), 0644)
	if err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	
	embedInfo := &FileEmbedInfo{
		FilePath:    testFilePath,
		DisplayName: "元数据测试文件.txt",
		Description: "这是一个用于测试元数据的文件",
		Tags:        []string{"test", "metadata", "file"},
		Category:    "test",
		Author:      "测试作者",
		Version:     "1.0.0",
		Metadata: map[string]interface{}{
			"custom_field": "custom_value",
			"number_field": 42,
			"bool_field":   true,
		},
	}
	
	err = embedder.EmbedFile(ctx, embedInfo)
	if err != nil {
		t.Fatalf("带元数据嵌入文件失败: %v", err)
	}
	
	// 验证元数据已保存
	retrievedInfo, err := embedder.GetEmbeddedFile(embedInfo.ID)
	if err != nil {
		t.Fatalf("获取带元数据的嵌入文件失败: %v", err)
	}
	
	if retrievedInfo.Description != "这是一个用于测试元数据的文件" {
		t.Errorf("描述不匹配，期望: 这是一个用于测试元数据的文件, 实际: %s", retrievedInfo.Description)
	}
	
	if len(retrievedInfo.Tags) != 3 {
		t.Errorf("标签数量不匹配，期望: 3, 实际: %d", len(retrievedInfo.Tags))
	}
	
	if retrievedInfo.Category != "test" {
		t.Errorf("类别不匹配，期望: test, 实际: %s", retrievedInfo.Category)
	}
	
	if retrievedInfo.Author != "测试作者" {
		t.Errorf("作者不匹配，期望: 测试作者, 实际: %s", retrievedInfo.Author)
	}
	
	if retrievedInfo.Version != "1.0.0" {
		t.Errorf("版本不匹配，期望: 1.0.0, 实际: %s", retrievedInfo.Version)
	}
	
	// 验证自定义元数据
	if retrievedInfo.Metadata["custom_field"] != "custom_value" {
		t.Errorf("自定义字段不匹配，期望: custom_value, 实际: %v", retrievedInfo.Metadata["custom_field"])
	}
	
	if retrievedInfo.Metadata["number_field"] != 42 {
		t.Errorf("数字字段不匹配，期望: 42, 实际: %v", retrievedInfo.Metadata["number_field"])
	}
	
	if retrievedInfo.Metadata["bool_field"] != true {
		t.Errorf("布尔字段不匹配，期望: true, 实际: %v", retrievedInfo.Metadata["bool_field"])
	}
}

// TestEmbedFilePerformance 测试嵌入文件性能
func TestEmbedFilePerformance(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	// 创建临时测试文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	testFilePath := filepath.Join(tempDir, "performance_test.txt")
	testContent := "性能测试文件内容"
	
	err = os.WriteFile(testFilePath, []byte(testContent), 0644)
	if err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}
	
	embedInfo := &FileEmbedInfo{
		FilePath:    testFilePath,
		DisplayName: "性能测试文件.txt",
	}
	
	// 测试嵌入性能
	start := time.Now()
	err = embedder.EmbedFile(ctx, embedInfo)
	duration := time.Since(start)
	
	if err != nil {
		t.Fatalf("性能测试嵌入文件失败: %v", err)
	}
	
	// 验证文件已嵌入
	if embedInfo.ID == "" {
		t.Error("性能测试嵌入文件ID应该自动生成")
	}
	
	// 验证嵌入时间合理（应该小于100毫秒）
	if duration > 100*time.Millisecond {
		t.Errorf("文件嵌入时间过长: %v", duration)
	}
	
	t.Logf("文件嵌入耗时: %v", duration)
}

// TestEmbedFileErrorHandling 测试嵌入文件错误处理
func TestEmbedFileErrorHandling(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	// 测试nil嵌入信息
	err := embedder.EmbedFile(ctx, nil)
	if err == nil {
		t.Error("nil嵌入信息应该导致嵌入失败")
	}
	
	// 测试空文件路径
	embedInfo := &FileEmbedInfo{
		FilePath:    "",
		DisplayName: "空路径文件.txt",
	}
	
	err = embedder.EmbedFile(ctx, embedInfo)
	if err == nil {
		t.Error("空文件路径应该导致嵌入失败")
	}
	
	// 测试相对路径
	embedInfo2 := &FileEmbedInfo{
		FilePath:    "relative/path/file.txt",
		DisplayName: "相对路径文件.txt",
	}
	
	err = embedder.EmbedFile(ctx, embedInfo2)
	if err == nil {
		t.Error("相对路径应该导致嵌入失败")
	}
}

// TestFileEmbedderStats 测试文件嵌入器统计信息
func TestFileEmbedderStats(t *testing.T) {
	embedder := NewFileEmbedder(nil)
	ctx := context.Background()
	
	// 获取初始统计
	initialStats := embedder.GetStats()
	if initialStats.TotalFiles != 0 {
		t.Errorf("初始文件总数应该为0，实际: %d", initialStats.TotalFiles)
	}
	
	if initialStats.TotalSize != 0 {
		t.Errorf("初始总大小应该为0，实际: %d", initialStats.TotalSize)
	}
	
	// 嵌入一些文件
	tempDir, err := os.MkdirTemp("", "file_embed_test")
	if err != nil {
		t.Fatalf("创建临时目录失败: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	files := []struct {
		path        string
		content     string
		displayName string
	}{
		{filepath.Join(tempDir, "small.txt"), "小文件", "小文件.txt"},
		{filepath.Join(tempDir, "medium.txt"), "中等文件内容", "中等文件.txt"},
		{filepath.Join(tempDir, "large.txt"), "大文件内容，包含更多文本内容", "大文件.txt"},
	}
	
	for _, file := range files {
		err = os.WriteFile(file.path, []byte(file.content), 0644)
		if err != nil {
			t.Fatalf("创建测试文件失败: %v", err)
		}
		
		embedInfo := &FileEmbedInfo{
			FilePath:    file.path,
			DisplayName: file.displayName,
		}
		
		err = embedder.EmbedFile(ctx, embedInfo)
		if err != nil {
			t.Fatalf("嵌入文件失败: %v", err)
		}
	}
	
	// 获取更新后的统计
	updatedStats := embedder.GetStats()
	if updatedStats.TotalFiles != 3 {
		t.Errorf("文件总数应该为3，实际: %d", updatedStats.TotalFiles)
	}
	
	if updatedStats.TotalSize <= 0 {
		t.Error("总大小应该大于0")
	}
	
	// 验证文件类型统计
	fileTypeCount := updatedStats.FileTypeCount
	if fileTypeCount[".txt"] != 3 {
		t.Errorf("TXT文件数量应该为3，实际: %d", fileTypeCount[".txt"])
	}
	
	// 验证平均文件大小
	if updatedStats.AverageFileSize <= 0 {
		t.Error("平均文件大小应该大于0")
	}
	
	// 验证最大文件大小
	if updatedStats.MaxFileSize <= 0 {
		t.Error("最大文件大小应该大于0")
	}
}
