package wordprocessingml

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/tanqiangyes/go-word/pkg/utils"
)

// TestNewTextProcessor 测试创建文本处理器
func TestNewTextProcessor(t *testing.T) {
	// 测试默认配置
	tp := NewTextProcessor(nil)
	if tp == nil {
		t.Fatal("文本处理器创建失败")
	}

	// 验证默认配置
	if tp.config.MaxTextLength != 1000000 {
		t.Errorf("默认最大文本长度不匹配，期望: 1000000, 实际: %d", tp.config.MaxTextLength)
	}

	if !tp.config.SpellCheckEnabled {
		t.Error("默认拼写检查应该启用")
	}

	if !tp.config.GrammarCheckEnabled {
		t.Error("默认语法检查应该启用")
	}

	// 测试自定义配置
	customConfig := &TextProcessorConfig{
		MaxTextLength:     500000,
		SpellCheckEnabled: false,
		GrammarCheckEnabled: false,
		Language:          "zh-CN",
	}

	tp2 := NewTextProcessor(customConfig)
	if tp2.config.MaxTextLength != 500000 {
		t.Errorf("自定义最大文本长度不匹配，期望: 500000, 实际: %d", tp2.config.MaxTextLength)
	}

	if tp2.config.SpellCheckEnabled {
		t.Error("自定义配置应该禁用拼写检查")
	}
}

// TestNewFontManager 测试创建字体管理器
func TestNewFontManager(t *testing.T) {
	tp := NewTextProcessor(nil)
	fm := tp.NewFontManager()

	if fm == nil {
		t.Fatal("字体管理器创建失败")
	}

	// 验证默认字体已加载
	if len(fm.fonts) == 0 {
		t.Error("默认字体应该被加载")
	}
}

// TestNewParagraphManager 测试创建段落管理器
func TestNewParagraphManager(t *testing.T) {
	tp := NewTextProcessor(nil)
	pm := tp.NewParagraphManager()

	if pm == nil {
		t.Fatal("段落管理器创建失败")
	}

	// 验证默认设置已加载
	if pm.defaultSettings == nil {
		t.Error("默认设置应该被加载")
	}
}

// TestProcessText 测试文本处理
func TestProcessText(t *testing.T) {
	tp := NewTextProcessor(nil)
	ctx := context.Background()

	// 测试基本文本处理
	text := &TextProcessorText{
		Content: "这是一个测试文本。",
		Style: &TextProcessorStyle{
			FontFamily: "Arial",
			FontSize:   12,
			Color:      "#000000",
		},
	}

	result, err := tp.ProcessText(ctx, text)
	if err != nil {
		t.Fatalf("文本处理失败: %v", err)
	}

	if result == nil {
		t.Fatal("处理结果不应该为空")
	}

	if result.ProcessedContent == "" {
		t.Error("处理后的内容不应该为空")
	}
}

// TestProcessTextWithLongContent 测试长文本处理
func TestProcessTextWithLongContent(t *testing.T) {
	tp := NewTextProcessor(nil)
	ctx := context.Background()

	// 创建超长文本
	longContent := ""
	for i := 0; i < 1000001; i++ {
		longContent += "a"
	}

	text := &TextProcessorText{
		Content: longContent,
		Style:   &TextProcessorStyle{},
	}

	_, err := tp.ProcessText(ctx, text)
	if err == nil {
		t.Error("超长文本应该被拒绝")
	}
}

// TestProcessTextWithInvalidStyle 测试无效样式处理
func TestProcessTextWithInvalidStyle(t *testing.T) {
	tp := NewTextProcessor(nil)
	ctx := context.Background()

	text := &TextProcessorText{
		Content: "测试文本",
		Style: &TextProcessorStyle{
			FontSize: -1, // 无效字体大小
		},
	}

	_, err := tp.ProcessText(ctx, text)
	if err == nil {
		t.Error("无效样式应该被拒绝")
	}
}

// TestTextProcessorConcurrency 测试并发处理
func TestTextProcessorConcurrency(t *testing.T) {
	tp := NewTextProcessor(nil)
	ctx := context.Background()
	numGoroutines := 10
	results := make(chan error, numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		go func(id int) {
			text := &TextProcessorText{
				Content: fmt.Sprintf("并发测试文本 %d", id),
				Style:   &TextProcessorStyle{},
			}
			_, err := tp.ProcessText(ctx, text)
			results <- err
		}(i)
	}

	// 收集结果
	for i := 0; i < numGoroutines; i++ {
		err := <-results
		if err != nil {
			t.Errorf("并发处理失败: %v", err)
		}
	}
}

// TestTextProcessorMemoryLimits 测试内存限制
func TestTextProcessorMemoryLimits(t *testing.T) {
	// 创建限制配置
	config := &TextProcessorConfig{
		MaxTextLength: 100,
		MaxFonts:      2,
		MaxStyles:     3,
	}

	tp := NewTextProcessor(config)
	ctx := context.Background()

	// 测试文本长度限制
	longText := ""
	for i := 0; i < 101; i++ {
		longText += "a"
	}

	text := &TextProcessorText{
		Content: longText,
		Style:   &TextProcessorStyle{},
	}

	_, err := tp.ProcessText(ctx, text)
	if err == nil {
		t.Error("超长文本应该被拒绝")
	}
}

// TestTextProcessorTemplates 测试文本模板
func TestTextProcessorTemplates(t *testing.T) {
	tp := NewTextProcessor(nil)

	// 测试获取默认样式
	style := tp.NewTextProcessorStyleManager().GetDefaultStyle()
	if style == nil {
		t.Error("默认样式应该存在")
	}

	if style.FontFamily == "" {
		t.Error("默认字体族应该设置")
	}

	if style.FontSize <= 0 {
		t.Error("默认字体大小应该大于0")
	}
}

// TestTextProcessorDefaultValues 测试默认值设置
func TestTextProcessorDefaultValues(t *testing.T) {
	tp := NewTextProcessor(nil)
	ctx := context.Background()

	// 创建没有样式的文本
	text := &TextProcessorText{
		Content: "默认值测试文本",
	}

	result, err := tp.ProcessText(ctx, text)
	if err != nil {
		t.Fatalf("文本处理失败: %v", err)
	}

	// 验证默认样式已设置
	if result.Style == nil {
		t.Error("默认样式应该被设置")
	}

	if result.Style.FontFamily == "" {
		t.Error("默认字体族应该被设置")
	}
}

// TestTextProcessorErrorHandling 测试错误处理
func TestTextProcessorErrorHandling(t *testing.T) {
	tp := NewTextProcessor(nil)
	ctx := context.Background()

	// 测试空内容
	text := &TextProcessorText{
		Content: "",
		Style:   &TextProcessorStyle{},
	}

	_, err := tp.ProcessText(ctx, text)
	if err == nil {
		t.Error("空内容应该被拒绝")
	}

	// 测试nil文本
	_, err = tp.ProcessText(ctx, nil)
	if err == nil {
		t.Error("nil文本应该被拒绝")
	}
}

// TestTextProcessorStats 测试统计信息
func TestTextProcessorStats(t *testing.T) {
	tp := NewTextProcessor(nil)
	ctx := context.Background()

	// 处理一些文本
	texts := []string{"文本1", "文本2", "文本3"}
	for _, content := range texts {
		text := &TextProcessorText{
			Content: content,
			Style:   &TextProcessorStyle{},
		}
		_, err := tp.ProcessText(ctx, text)
		if err != nil {
			t.Fatalf("处理文本失败: %v", err)
		}
	}

	// 获取统计信息
	stats := tp.GetMetrics()
	if stats == nil {
		t.Error("统计信息不应该为空")
	}

	// 验证处理数量
	if stats["processed_texts"].(int) != len(texts) {
		t.Errorf("处理的文本数量不匹配，期望: %d, 实际: %d", len(texts), stats["processed_texts"].(int))
	}
}

// TestTextProcessorPerformance 测试性能
func TestTextProcessorPerformance(t *testing.T) {
	tp := NewTextProcessor(nil)
	ctx := context.Background()

	// 测试大量文本处理性能
	start := time.Now()
	numTexts := 1000

	for i := 0; i < numTexts; i++ {
		text := &TextProcessorText{
			Content: fmt.Sprintf("性能测试文本 %d", i),
			Style:   &TextProcessorStyle{},
		}
		_, err := tp.ProcessText(ctx, text)
		if err != nil {
			t.Fatalf("处理文本失败: %v", err)
		}
	}

	duration := time.Since(start)
	avgTime := duration / time.Duration(numTexts)

	// 验证性能（平均每个文本处理时间应该小于1毫秒）
	if avgTime > time.Millisecond {
		t.Errorf("文本处理性能过低，平均时间: %v", avgTime)
	}
}

// TestTextProcessorLanguageSupport 测试语言支持
func TestTextProcessorLanguageSupport(t *testing.T) {
	tp := NewTextProcessor(nil)
	ls := tp.NewLanguageSupport()

	if ls == nil {
		t.Fatal("语言支持创建失败")
	}

	// 验证支持的语言
	supportedLanguages := ls.GetSupportedLanguages()
	if len(supportedLanguages) == 0 {
		t.Error("应该支持至少一种语言")
	}

	// 验证中文支持
	hasChinese := false
	for _, lang := range supportedLanguages {
		if lang.Code == "zh-CN" {
			hasChinese = true
			break
		}
	}

	if !hasChinese {
		t.Error("应该支持中文")
	}
}

// TestTextProcessorEffects 测试文本效果
func TestTextProcessorEffects(t *testing.T) {
	tp := NewTextProcessor(nil)
	em := tp.NewTextEffectManager()

	if em == nil {
		t.Fatal("文本效果管理器创建失败")
	}

	// 验证可用的效果
	effects := em.GetAvailableEffects()
	if len(effects) == 0 {
		t.Error("应该有可用的文本效果")
	}

	// 验证阴影效果
	hasShadow := false
	for _, effect := range effects {
		if effect.Type == "shadow" {
			hasShadow = true
			break
		}
	}

	if !hasShadow {
		t.Error("应该支持阴影效果")
	}
}
