package wordprocessingml

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"testing"
	"time"
)

// MockDocument æ¨¡æ‹Ÿæ–‡æ¡£
type MockDocument struct {
	content string
	path    string
}

func (md *MockDocument) GetText() (string, error) {
	return md.content, nil
}

func (md *MockDocument) Close() error {
	return nil
}

// TestNewPDFExporter æµ‹è¯•åˆ›å»ºPDFå¯¼å‡ºå™¨
func TestNewPDFExporter(t *testing.T) {
	doc := &MockDocument{content: "æµ‹è¯•æ–‡æ¡£å†…å®¹"}
	
	exporter := NewPDFExporter(doc, nil)
	if exporter == nil {
		t.Fatal("PDFå¯¼å‡ºå™¨åˆ›å»ºå¤±è´¥")
	}
	
	if exporter.document != doc {
		t.Error("æ–‡æ¡£å¼•ç”¨ä¸åŒ¹é…")
	}
}

// TestNewPDFExporterWithConfig æµ‹è¯•ä½¿ç”¨é…ç½®åˆ›å»ºPDFå¯¼å‡ºå™¨
func TestNewPDFExporterWithConfig(t *testing.T) {
	doc := &MockDocument{content: "æµ‹è¯•æ–‡æ¡£å†…å®¹"}
	config := &PDFExportConfig{
		Quality:     "high",
		Compression: true,
		Metadata: map[string]string{
			"Title":   "æµ‹è¯•æ–‡æ¡£",
			"Author":  "æµ‹è¯•ä½œè€…",
			"Subject": "æµ‹è¯•ä¸»é¢˜",
		},
	}
	
	exporter := NewPDFExporter(doc, config)
	if exporter == nil {
		t.Fatal("PDFå¯¼å‡ºå™¨åˆ›å»ºå¤±è´¥")
	}
	
	if exporter.config.Quality != "high" {
		t.Errorf("é…ç½®è´¨é‡ä¸åŒ¹é…ï¼ŒæœŸæœ›: high, å®é™…: %s", exporter.config.Quality)
	}
	
	if !exporter.config.Compression {
		t.Error("é…ç½®å‹ç¼©åº”è¯¥å¯ç”¨")
	}
	
	if exporter.config.Metadata["Title"] != "æµ‹è¯•æ–‡æ¡£" {
		t.Errorf("é…ç½®å…ƒæ•°æ®æ ‡é¢˜ä¸åŒ¹é…ï¼ŒæœŸæœ›: æµ‹è¯•æ–‡æ¡£, å®é™…: %s", exporter.config.Metadata["Title"])
	}
}

// TestExportToPDF æµ‹è¯•PDFå¯¼å‡º
func TestExportToPDF(t *testing.T) {
	doc := &MockDocument{content: "æµ‹è¯•æ–‡æ¡£å†…å®¹"}
	exporter := NewPDFExporter(doc, nil)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "test_output.pdf")
	
	// æµ‹è¯•å¯¼å‡º
	err = exporter.ExportToPDF(context.Background(), outputPath)
	if err != nil {
		t.Fatalf("PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
	if _, err := os.Stat(outputPath); os.IsNotExist(err) {
		t.Error("PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
	}
}

// TestExportToPDFWithInvalidPath æµ‹è¯•å¯¼å‡ºåˆ°æ— æ•ˆè·¯å¾„
func TestExportToPDFWithInvalidPath(t *testing.T) {
	doc := &MockDocument{content: "æµ‹è¯•æ–‡æ¡£å†…å®¹"}
	exporter := NewPDFExporter(doc, nil)
	
	// æµ‹è¯•å¯¼å‡ºåˆ°æ— æ•ˆè·¯å¾„
	err := exporter.ExportToPDF(context.Background(), "/invalid/path/test.pdf")
	if err == nil {
		t.Error("åº”è¯¥æ‹’ç»å¯¼å‡ºåˆ°æ— æ•ˆè·¯å¾„")
	}
}

// TestExportToPDFWithNilDocument æµ‹è¯•å¯¼å‡ºnilæ–‡æ¡£
func TestExportToPDFWithNilDocument(t *testing.T) {
	exporter := NewPDFExporter(nil, nil)
	
	err := exporter.ExportToPDF(context.Background(), "test.pdf")
	if err == nil {
		t.Error("åº”è¯¥æ‹’ç»å¯¼å‡ºnilæ–‡æ¡£")
	}
}

// TestExportToPDFWithEmptyContent æµ‹è¯•å¯¼å‡ºç©ºå†…å®¹æ–‡æ¡£
func TestExportToPDFWithEmptyContent(t *testing.T) {
	doc := &MockDocument{content: ""}
	exporter := NewPDFExporter(doc, nil)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "empty_content.pdf")
	
	// æµ‹è¯•å¯¼å‡ºç©ºå†…å®¹
	err = exporter.ExportToPDF(context.Background(), outputPath)
	if err != nil {
		t.Fatalf("ç©ºå†…å®¹PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
	if _, err := os.Stat(outputPath); os.IsNotExist(err) {
		t.Error("ç©ºå†…å®¹PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
	}
}

// TestExportToPDFWithSpecialCharacters æµ‹è¯•å¯¼å‡ºåŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ–‡æ¡£
func TestExportToPDFWithSpecialCharacters(t *testing.T) {
	doc := &MockDocument{content: "ç‰¹æ®Šå­—ç¬¦æµ‹è¯•ï¼š!@#$%^&*()_+-=[]{}|;':\",./<>?"}
	exporter := NewPDFExporter(doc, nil)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "special_chars.pdf")
	
	// æµ‹è¯•å¯¼å‡ºåŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ–‡æ¡£
	err = exporter.ExportToPDF(context.Background(), outputPath)
	if err != nil {
		t.Fatalf("ç‰¹æ®Šå­—ç¬¦PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
	if _, err := os.Stat(outputPath); os.IsNotExist(err) {
		t.Error("ç‰¹æ®Šå­—ç¬¦PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
	}
}

// TestExportToPDFWithUnicode æµ‹è¯•å¯¼å‡ºåŒ…å«Unicodeå­—ç¬¦çš„æ–‡æ¡£
func TestExportToPDFWithUnicode(t *testing.T) {
	doc := &MockDocument{content: "Unicodeæµ‹è¯•ï¼šä¸­æ–‡æµ‹è¯•ï¼Œæ—¥æœ¬èªãƒ†ã‚¹ãƒˆï¼Œí•œêµ­ì–´ í…ŒìŠ¤íŠ¸ï¼ŒğŸŒğŸŒğŸŒ"}
	exporter := NewPDFExporter(doc, nil)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "unicode_test.pdf")
	
	// æµ‹è¯•å¯¼å‡ºåŒ…å«Unicodeå­—ç¬¦çš„æ–‡æ¡£
	err = exporter.ExportToPDF(context.Background(), outputPath)
	if err != nil {
		t.Fatalf("Unicode PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
	if _, err := os.Stat(outputPath); os.IsNotExist(err) {
		t.Error("Unicode PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
	}
}

// TestExportToPDFWithLongContent æµ‹è¯•å¯¼å‡ºé•¿å†…å®¹æ–‡æ¡£
func TestExportToPDFWithLongContent(t *testing.T) {
	// ç”Ÿæˆé•¿å†…å®¹
	longContent := ""
	for i := 0; i < 1000; i++ {
		longContent += fmt.Sprintf("è¿™æ˜¯ç¬¬%dè¡Œå†…å®¹ï¼ŒåŒ…å«ä¸€äº›æµ‹è¯•æ–‡æœ¬ã€‚", i+1)
		if i%10 == 0 {
			longContent += "\n"
		}
	}
	
	doc := &MockDocument{content: longContent}
	exporter := NewPDFExporter(doc, nil)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "long_content.pdf")
	
	// æµ‹è¯•å¯¼å‡ºé•¿å†…å®¹
	err = exporter.ExportToPDF(context.Background(), outputPath)
	if err != nil {
		t.Fatalf("é•¿å†…å®¹PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
	if _, err := os.Stat(outputPath); os.IsNotExist(err) {
		t.Error("é•¿å†…å®¹PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
	}
}

// TestExportToPDFWithDifferentConfigs æµ‹è¯•ä¸åŒé…ç½®çš„PDFå¯¼å‡º
func TestExportToPDFWithDifferentConfigs(t *testing.T) {
	doc := &MockDocument{content: "é…ç½®æµ‹è¯•æ–‡æ¡£"}
	
	testConfigs := []*PDFExportConfig{
		{
			Quality:     "low",
			Compression: false,
			Metadata: map[string]string{
				"Title": "ä½è´¨é‡PDF",
			},
		},
		{
			Quality:     "medium",
			Compression: true,
			Metadata: map[string]string{
				"Title": "ä¸­ç­‰è´¨é‡PDF",
			},
		},
		{
			Quality:     "high",
			Compression: true,
			Metadata: map[string]string{
				"Title": "é«˜è´¨é‡PDF",
			},
		},
	}
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	for i, config := range testConfigs {
		exporter := NewPDFExporter(doc, config)
		outputPath := filepath.Join(tempDir, fmt.Sprintf("config_test_%d.pdf", i))
		
		// æµ‹è¯•å¯¼å‡º
		err := exporter.ExportToPDF(context.Background(), outputPath)
		if err != nil {
			t.Fatalf("é…ç½®%d PDFå¯¼å‡ºå¤±è´¥: %v", i+1, err)
		}
		
		// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
		if _, err := os.Stat(outputPath); os.IsNotExist(err) {
			t.Errorf("é…ç½®%d PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º", i+1)
		}
	}
}

// TestExportToPDFConcurrency æµ‹è¯•å¹¶å‘PDFå¯¼å‡º
func TestExportToPDFConcurrency(t *testing.T) {
	doc := &MockDocument{content: "å¹¶å‘æµ‹è¯•æ–‡æ¡£"}
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	const numGoroutines = 5
	errors := make(chan error, numGoroutines)
	
	for i := 0; i < numGoroutines; i++ {
		go func(id int) {
			exporter := NewPDFExporter(doc, nil)
			outputPath := filepath.Join(tempDir, fmt.Sprintf("concurrent_%d.pdf", id))
			
			err := exporter.ExportToPDF(context.Background(), outputPath)
			errors <- err
		}(i)
	}
	
	// æ”¶é›†é”™è¯¯
	for i := 0; i < numGoroutines; i++ {
		err := <-errors
		if err != nil {
			t.Errorf("å¹¶å‘PDFå¯¼å‡º%då¤±è´¥: %v", i+1, err)
		}
	}
	
	// éªŒè¯æ‰€æœ‰æ–‡ä»¶éƒ½å·²åˆ›å»º
	for i := 0; i < numGoroutines; i++ {
		outputPath := filepath.Join(tempDir, fmt.Sprintf("concurrent_%d.pdf", i))
		if _, err := os.Stat(outputPath); os.IsNotExist(err) {
			t.Errorf("å¹¶å‘PDFæ–‡ä»¶%dåº”è¯¥è¢«åˆ›å»º", i+1)
		}
	}
}

// TestExportToPDFWithContext æµ‹è¯•å¸¦ä¸Šä¸‹æ–‡çš„PDFå¯¼å‡º
func TestExportToPDFWithContext(t *testing.T) {
	doc := &MockDocument{content: "ä¸Šä¸‹æ–‡æµ‹è¯•æ–‡æ¡£"}
	exporter := NewPDFExporter(doc, nil)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "context_test.pdf")
	
	// æµ‹è¯•å¸¦ä¸Šä¸‹æ–‡çš„å¯¼å‡º
	ctx := context.Background()
	err = exporter.ExportToPDF(ctx, outputPath)
	if err != nil {
		t.Fatalf("å¸¦ä¸Šä¸‹æ–‡çš„PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
	if _, err := os.Stat(outputPath); os.IsNotExist(err) {
		t.Error("å¸¦ä¸Šä¸‹æ–‡çš„PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
	}
}

// TestExportToPDFWithCancelledContext æµ‹è¯•å–æ¶ˆä¸Šä¸‹æ–‡çš„PDFå¯¼å‡º
func TestExportToPDFWithCancelledContext(t *testing.T) {
	doc := &MockDocument{content: "å–æ¶ˆä¸Šä¸‹æ–‡æµ‹è¯•æ–‡æ¡£"}
	exporter := NewPDFExporter(doc, nil)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "cancelled_context.pdf")
	
	// åˆ›å»ºå·²å–æ¶ˆçš„ä¸Šä¸‹æ–‡
	ctx, cancel := context.WithCancel(context.Background())
	cancel() // ç«‹å³å–æ¶ˆ
	
	// æµ‹è¯•å·²å–æ¶ˆä¸Šä¸‹æ–‡çš„å¯¼å‡º
	err = exporter.ExportToPDF(ctx, outputPath)
	if err == nil {
		t.Error("å·²å–æ¶ˆä¸Šä¸‹æ–‡çš„PDFå¯¼å‡ºåº”è¯¥å¤±è´¥")
	}
}

// TestExportToPDFWithTimeoutContext æµ‹è¯•è¶…æ—¶ä¸Šä¸‹æ–‡çš„PDFå¯¼å‡º
func TestExportToPDFWithTimeoutContext(t *testing.T) {
	doc := &MockDocument{content: "è¶…æ—¶ä¸Šä¸‹æ–‡æµ‹è¯•æ–‡æ¡£"}
	exporter := NewPDFExporter(doc, nil)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "timeout_context.pdf")
	
	// åˆ›å»ºè¶…æ—¶ä¸Šä¸‹æ–‡
	ctx, cancel := context.WithTimeout(context.Background(), 1) // 1çº³ç§’è¶…æ—¶
	defer cancel()
	
	// æµ‹è¯•è¶…æ—¶ä¸Šä¸‹æ–‡çš„å¯¼å‡º
	err = exporter.ExportToPDF(ctx, outputPath)
	if err == nil {
		t.Error("è¶…æ—¶ä¸Šä¸‹æ–‡çš„PDFå¯¼å‡ºåº”è¯¥å¤±è´¥")
	}
}

// TestExportToPDFFileSize æµ‹è¯•PDFæ–‡ä»¶å¤§å°
func TestExportToPDFFileSize(t *testing.T) {
	doc := &MockDocument{content: "æ–‡ä»¶å¤§å°æµ‹è¯•æ–‡æ¡£"}
	exporter := NewPDFExporter(doc, nil)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "file_size_test.pdf")
	
	// æµ‹è¯•å¯¼å‡º
	err = exporter.ExportToPDF(context.Background(), outputPath)
	if err != nil {
		t.Fatalf("æ–‡ä»¶å¤§å°æµ‹è¯•PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
	fileInfo, err := os.Stat(outputPath)
	if err != nil {
		t.Fatalf("è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥: %v", err)
	}
	
	// éªŒè¯æ–‡ä»¶å¤§å°å¤§äº0
	if fileInfo.Size() <= 0 {
		t.Error("PDFæ–‡ä»¶å¤§å°åº”è¯¥å¤§äº0")
	}
	
	// éªŒè¯æ–‡ä»¶å¤§å°åˆç†ï¼ˆè‡³å°‘å‡ ç™¾å­—èŠ‚ï¼‰
	if fileInfo.Size() < 100 {
		t.Errorf("PDFæ–‡ä»¶å¤§å°åº”è¯¥åˆç†ï¼Œå®é™…: %d bytes", fileInfo.Size())
	}
}

// TestExportToPDFWithMetadata æµ‹è¯•å¸¦å…ƒæ•°æ®çš„PDFå¯¼å‡º
func TestExportToPDFWithMetadata(t *testing.T) {
	doc := &MockDocument{content: "å…ƒæ•°æ®æµ‹è¯•æ–‡æ¡£"}
	config := &PDFExportConfig{
		Metadata: map[string]string{
			"Title":    "æµ‹è¯•æ–‡æ¡£æ ‡é¢˜",
			"Author":   "æµ‹è¯•ä½œè€…",
			"Subject":  "æµ‹è¯•ä¸»é¢˜",
			"Keywords": "æµ‹è¯•,PDF,å¯¼å‡º",
			"Creator":  "Go Word Library",
			"Producer": "Go Word PDF Exporter",
		},
	}
	
	exporter := NewPDFExporter(doc, config)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "metadata_test.pdf")
	
	// æµ‹è¯•å¯¼å‡º
	err = exporter.ExportToPDF(context.Background(), outputPath)
	if err != nil {
		t.Fatalf("å…ƒæ•°æ®æµ‹è¯•PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
	if _, err := os.Stat(outputPath); os.IsNotExist(err) {
		t.Error("å…ƒæ•°æ®æµ‹è¯•PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
	}
}

// TestExportToPDFWithCompression æµ‹è¯•å‹ç¼©PDFå¯¼å‡º
func TestExportToPDFWithCompression(t *testing.T) {
	doc := &MockDocument{content: "å‹ç¼©æµ‹è¯•æ–‡æ¡£"}
	
	// æµ‹è¯•å¯ç”¨å‹ç¼©
	compressedConfig := &PDFExportConfig{
		Compression: true,
	}
	
	exporter := NewPDFExporter(doc, compressedConfig)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	compressedPath := filepath.Join(tempDir, "compressed.pdf")
	
	// æµ‹è¯•å‹ç¼©å¯¼å‡º
	err = exporter.ExportToPDF(context.Background(), compressedPath)
	if err != nil {
		t.Fatalf("å‹ç¼©PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// æµ‹è¯•ç¦ç”¨å‹ç¼©
	uncompressedConfig := &PDFExportConfig{
		Compression: false,
	}
	
	exporter2 := NewPDFExporter(doc, uncompressedConfig)
	uncompressedPath := filepath.Join(tempDir, "uncompressed.pdf")
	
	// æµ‹è¯•éå‹ç¼©å¯¼å‡º
	err = exporter2.ExportToPDF(context.Background(), uncompressedPath)
	if err != nil {
		t.Fatalf("éå‹ç¼©PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// éªŒè¯ä¸¤ä¸ªæ–‡ä»¶éƒ½å·²åˆ›å»º
	if _, err := os.Stat(compressedPath); os.IsNotExist(err) {
		t.Error("å‹ç¼©PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
	}
	
	if _, err := os.Stat(uncompressedPath); os.IsNotExist(err) {
		t.Error("éå‹ç¼©PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
	}
}

// TestExportToPDFWithQuality æµ‹è¯•ä¸åŒè´¨é‡çš„PDFå¯¼å‡º
func TestExportToPDFWithQuality(t *testing.T) {
	doc := &MockDocument{content: "è´¨é‡æµ‹è¯•æ–‡æ¡£"}
	
	qualities := []string{"low", "medium", "high"}
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	for _, quality := range qualities {
		config := &PDFExportConfig{
			Quality: quality,
		}
		
		exporter := NewPDFExporter(doc, config)
		outputPath := filepath.Join(tempDir, fmt.Sprintf("quality_%s.pdf", quality))
		
		// æµ‹è¯•å¯¼å‡º
		err := exporter.ExportToPDF(context.Background(), outputPath)
		if err != nil {
			t.Fatalf("è´¨é‡%s PDFå¯¼å‡ºå¤±è´¥: %v", quality, err)
		}
		
		// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
		if _, err := os.Stat(outputPath); os.IsNotExist(err) {
			t.Errorf("è´¨é‡%s PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º", quality)
		}
	}
}

// TestExportToPDFErrorHandling æµ‹è¯•PDFå¯¼å‡ºé”™è¯¯å¤„ç†
func TestExportToPDFErrorHandling(t *testing.T) {
	// æµ‹è¯•nilæ–‡æ¡£
	exporter := NewPDFExporter(nil, nil)
	err := exporter.ExportToPDF(context.Background(), "test.pdf")
	if err == nil {
		t.Error("nilæ–‡æ¡£åº”è¯¥å¯¼è‡´å¯¼å‡ºå¤±è´¥")
	}
	
	// æµ‹è¯•ç©ºè·¯å¾„
	doc := &MockDocument{content: "é”™è¯¯å¤„ç†æµ‹è¯•æ–‡æ¡£"}
	exporter2 := NewPDFExporter(doc, nil)
	err = exporter2.ExportToPDF(context.Background(), "")
	if err == nil {
		t.Error("ç©ºè·¯å¾„åº”è¯¥å¯¼è‡´å¯¼å‡ºå¤±è´¥")
	}
	
	// æµ‹è¯•ç›¸å¯¹è·¯å¾„
	err = exporter2.ExportToPDF(context.Background(), "relative/path/test.pdf")
	if err == nil {
		t.Error("ç›¸å¯¹è·¯å¾„åº”è¯¥å¯¼è‡´å¯¼å‡ºå¤±è´¥")
	}
}

// TestExportToPDFPerformance æµ‹è¯•PDFå¯¼å‡ºæ€§èƒ½
func TestExportToPDFPerformance(t *testing.T) {
	doc := &MockDocument{content: "æ€§èƒ½æµ‹è¯•æ–‡æ¡£"}
	exporter := NewPDFExporter(doc, nil)
	
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "pdf_export_test")
	if err != nil {
		t.Fatalf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	defer os.RemoveAll(tempDir)
	
	outputPath := filepath.Join(tempDir, "performance_test.pdf")
	
	// æµ‹è¯•å¯¼å‡ºæ€§èƒ½
	start := time.Now()
	err = exporter.ExportToPDF(context.Background(), outputPath)
	duration := time.Since(start)
	
	if err != nil {
		t.Fatalf("æ€§èƒ½æµ‹è¯•PDFå¯¼å‡ºå¤±è´¥: %v", err)
	}
	
	// éªŒè¯æ–‡ä»¶å·²åˆ›å»º
	if _, err := os.Stat(outputPath); os.IsNotExist(err) {
		t.Error("æ€§èƒ½æµ‹è¯•PDFæ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
	}
	
	// éªŒè¯å¯¼å‡ºæ—¶é—´åˆç†ï¼ˆåº”è¯¥å°äº1ç§’ï¼‰
	if duration > time.Second {
		t.Errorf("PDFå¯¼å‡ºæ—¶é—´è¿‡é•¿: %v", duration)
	}
	
	t.Logf("PDFå¯¼å‡ºè€—æ—¶: %v", duration)
}
