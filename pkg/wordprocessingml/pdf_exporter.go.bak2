package wordprocessingml

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/tanqiangyes/go-word/pkg/types"
	"github.com/tanqiangyes/go-word/pkg/utils"
)

// PDFExporter PDF导出器
type PDFExporter struct {
	document     *Document
	config       *types.PDFExportConfig
	logger       *utils.Logger
	mu           sync.RWMutex
	metrics      *PDFExportMetrics
}



// PDFExportMetrics PDF导出指标
type PDFExportMetrics struct {
	ExportsTotal     int64         `json:"exports_total"`
	ExportsSuccess   int64         `json:"exports_success"`
	ExportsFailed    int64         `json:"exports_failed"`
	AverageTime      time.Duration `json:"average_time"`
	TotalTime        time.Duration `json:"total_time"`
	LastExportTime   time.Time     `json:"last_export_time"`
	AverageFileSize  int64         `json:"average_file_size"`
}

// PDFExportResult PDF导出结果
type PDFExportResult struct {
	Success     bool          `json:"success"`
	FilePath    string        `json:"file_path"`
	FileSize    int64         `json:"file_size"`
	PageCount   int           `json:"page_count"`
	ExportTime  time.Duration `json:"export_time"`
	Error       error         `json:"error,omitempty"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// NewPDFExporter 创建PDF导出器
func NewPDFExporter(document *Document, config *types.PDFExportConfig) *PDFExporter {
	if config == nil {
		config = getDefaultPDFConfig()
	}
	
	return &PDFExporter{
		document: document,
		config:   config,
		logger:   utils.NewLogger(utils.LogLevelInfo, os.Stdout),
		metrics:  &PDFExportMetrics{},
	}
}

// ExportToPDF 导出为PDF
func (pe *PDFExporter) ExportToPDF(ctx context.Context, outputPath string) (*PDFExportResult, error) {
	pe.mu.Lock()
	defer pe.mu.Unlock()
	
	startTime := time.Now()
	pe.metrics.ExportsTotal++
	
	result := &PDFExportResult{
		FilePath: outputPath,
		Metadata: make(map[string]interface{}),
	}
	
	// 验证输入
	if pe.document == nil {
		err := fmt.Errorf("document is nil")
		pe.handleExportError(err, result)
		return result, err
	}
	
	if outputPath == "" {
		err := fmt.Errorf("output path is empty")
		pe.handleExportError(err, result)
		return result, err
	}
	
	pe.logger.Info("开始PDF导出", map[string]interface{}{
		"output_path": outputPath,
		"config":      pe.config,
	})
	
	// 提取文档内容
	content, err := pe.extractDocumentContent(ctx)
	if err != nil {
		pe.handleExportError(err, result)
		return result, fmt.Errorf("failed to extract document content: %w", err)
	}
	
	// 生成PDF
	pdfData, pageCount, err := pe.generatePDF(ctx, content)
	if err != nil {
		pe.handleExportError(err, result)
		return result, fmt.Errorf("failed to generate PDF: %w", err)
	}
	
	// 保存PDF文件
	err = pe.savePDFFile(outputPath, pdfData)
	if err != nil {
		pe.handleExportError(err, result)
		return result, fmt.Errorf("failed to save PDF file: %w", err)
	}
	
	// 更新结果
	exportTime := time.Since(startTime)
	result.Success = true
	result.FileSize = int64(len(pdfData))
	result.PageCount = pageCount
	result.ExportTime = exportTime
	
	// 更新指标
	pe.updateMetrics(exportTime, result.FileSize, true)
	
	pe.logger.Info("PDF导出完成", map[string]interface{}{
		"output_path": outputPath,
		"file_size":   result.FileSize,
		"page_count":  result.PageCount,
		"export_time": exportTime,
	})
	
	return result, nil
}

// ExportToPDFStream 导出为PDF流
func (pe *PDFExporter) ExportToPDFStream(ctx context.Context, writer io.Writer) (*PDFExportResult, error) {
	pe.mu.Lock()
	defer pe.mu.Unlock()
	
	startTime := time.Now()
	pe.metrics.ExportsTotal++
	
	result := &PDFExportResult{
		Metadata: make(map[string]interface{}),
	}
	
	// 验证输入
	if pe.document == nil {
		err := fmt.Errorf("document is nil")
		pe.handleExportError(err, result)
		return result, err
	}
	
	if writer == nil {
		err := fmt.Errorf("writer is nil")
		pe.handleExportError(err, result)
		return result, err
	}
	
	// 提取文档内容
	content, err := pe.extractDocumentContent(ctx)
	if err != nil {
		pe.handleExportError(err, result)
		return result, fmt.Errorf("failed to extract document content: %w", err)
	}
	
	// 生成PDF
	pdfData, pageCount, err := pe.generatePDF(ctx, content)
	if err != nil {
		pe.handleExportError(err, result)
		return result, fmt.Errorf("failed to generate PDF: %w", err)
	}
	
	// 写入流
	n, err := writer.Write(pdfData)
	if err != nil {
		pe.handleExportError(err, result)
		return result, fmt.Errorf("failed to write PDF stream: %w", err)
	}
	
	// 更新结果
	exportTime := time.Since(startTime)
	result.Success = true
	result.FileSize = int64(n)
	result.PageCount = pageCount
	result.ExportTime = exportTime
	
	// 更新指标
	pe.updateMetrics(exportTime, result.FileSize, true)
	
	return result, nil
}

// extractDocumentContent 提取文档内容
func (pe *PDFExporter) extractDocumentContent(ctx context.Context) (*PDFDocumentContent, error) {
	content := &PDFDocumentContent{
		Metadata: make(map[string]interface{}),
	}
	
	// 提取文本内容
	text, err := pe.document.GetText()
	if err != nil {
		return nil, fmt.Errorf("failed to get text: %w", err)
	}
	content.Text = text
	
	// 提取段落
	if paragraphs, err := pe.document.GetParagraphs(); err == nil {
		// 转换为指针切片
		for i := range paragraphs {
			content.Paragraphs = append(content.Paragraphs, &paragraphs[i])
		}
	}
	
	// 提取表格
	if pe.config.IncludeTables {
		if tables, err := pe.document.GetTables(); err == nil {
			// 转换为指针切片
			for i := range tables {
				content.Tables = append(content.Tables, &tables[i])
			}
		}
	}
	
	// 提取图片信息（如果支持）
	if pe.config.IncludeImages {
		// 这里可以添加图片提取逻辑
		content.Images = []types.PDFImageInfo{}
	}
	
	return content, nil
}

// generatePDF 生成PDF数据
func (pe *PDFExporter) generatePDF(ctx context.Context, content *PDFDocumentContent) ([]byte, int, error) {
	// 这里实现PDF生成逻辑
	// 为了简化，我们生成一个基本的PDF结构
	
	var buffer bytes.Buffer
	
	// PDF头部
	buffer.WriteString("%PDF-1.4\n")
	
	// 添加文档信息
	pe.addPDFDocumentInfo(&buffer)
	
	// 添加页面内容
	pageCount := pe.addPDFContent(&buffer, content)
	
	// PDF尾部
	pe.addPDFTrailer(&buffer)
	
	return buffer.Bytes(), pageCount, nil
}

// addPDFDocumentInfo 添加PDF文档信息
func (pe *PDFExporter) addPDFDocumentInfo(buffer *bytes.Buffer) {
	// 添加文档信息对象
	buffer.WriteString("1 0 obj\n")
	buffer.WriteString("<<\n")
	buffer.WriteString("/Type /Catalog\n")
	buffer.WriteString("/Pages 2 0 R\n")
	buffer.WriteString(">>\n")
	buffer.WriteString("endobj\n\n")
	
	// 添加页面树
	buffer.WriteString("2 0 obj\n")
	buffer.WriteString("<<\n")
	buffer.WriteString("/Type /Pages\n")
	buffer.WriteString("/Kids [3 0 R]\n")
	buffer.WriteString("/Count 1\n")
	buffer.WriteString(">>\n")
	buffer.WriteString("endobj\n\n")
}

// addPDFContent 添加PDF内容
func (pe *PDFExporter) addPDFContent(buffer *bytes.Buffer, content *PDFDocumentContent) int {
	// 添加页面对象
	buffer.WriteString("3 0 obj\n")
	buffer.WriteString("<<\n")
	buffer.WriteString("/Type /Page\n")
	buffer.WriteString("/Parent 2 0 R\n")
	buffer.WriteString("/MediaBox [0 0 612 792]\n") // A4 size
	buffer.WriteString("/Contents 4 0 R\n")
	buffer.WriteString("/Resources <<\n")
	buffer.WriteString("/Font <<\n")
	buffer.WriteString("/F1 5 0 R\n")
	buffer.WriteString(">>\n")
	buffer.WriteString(">>\n")
	buffer.WriteString(">>\n")
	buffer.WriteString("endobj\n\n")
	
	// 添加内容流
	contentStream := pe.generateContentStream(content)
	buffer.WriteString("4 0 obj\n")
	buffer.WriteString("<<\n")
	buffer.WriteString(fmt.Sprintf("/Length %d\n", len(contentStream)))
	buffer.WriteString(">>\n")
	buffer.WriteString("stream\n")
	buffer.WriteString(contentStream)
	buffer.WriteString("\nendstream\n")
	buffer.WriteString("endobj\n\n")
	
	// 添加字体
	buffer.WriteString("5 0 obj\n")
	buffer.WriteString("<<\n")
	buffer.WriteString("/Type /Font\n")
	buffer.WriteString("/Subtype /Type1\n")
	buffer.WriteString("/BaseFont /Helvetica\n")
	buffer.WriteString(">>\n")
	buffer.WriteString("endobj\n\n")
	
	return 1 // 返回页面数
}

// generateContentStream 生成内容流
func (pe *PDFExporter) generateContentStream(content *PDFDocumentContent) string {
	var stream strings.Builder
	
	// 开始文本
	stream.WriteString("BT\n")
	stream.WriteString("/F1 12 Tf\n")
	stream.WriteString("72 720 Td\n")
	
	// 添加文本内容
	lines := strings.Split(content.Text, "\n")
	for i, line := range lines {
		if i > 0 {
			stream.WriteString("0 -14 Td\n")
		}
		// 转义特殊字符
		escapedLine := pe.escapePDFString(line)
		stream.WriteString(fmt.Sprintf("(%s) Tj\n", escapedLine))
	}
	
	// 结束文本
	stream.WriteString("ET\n")
	
	return stream.String()
}

// escapePDFString 转义PDF字符串
func (pe *PDFExporter) escapePDFString(s string) string {
	// 转义PDF字符串中的特殊字符
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "(", "\\(")
	s = strings.ReplaceAll(s, ")", "\\)")
	return s
}

// addPDFTrailer 添加PDF尾部
func (pe *PDFExporter) addPDFTrailer(buffer *bytes.Buffer) {
	// 添加交叉引用表
	buffer.WriteString("xref\n")
	buffer.WriteString("0 6\n")
	buffer.WriteString("0000000000 65535 f \n")
	buffer.WriteString("0000000009 00000 n \n")
	buffer.WriteString("0000000074 00000 n \n")
	buffer.WriteString("0000000120 00000 n \n")
	buffer.WriteString("0000000274 00000 n \n")
	buffer.WriteString("0000000373 00000 n \n")
	
	// 添加尾部
	buffer.WriteString("trailer\n")
	buffer.WriteString("<<\n")
	buffer.WriteString("/Size 6\n")
	buffer.WriteString("/Root 1 0 R\n")
	buffer.WriteString(">>\n")
	buffer.WriteString("startxref\n")
	buffer.WriteString("492\n")
	buffer.WriteString("%%EOF\n")
}

// savePDFFile 保存PDF文件
func (pe *PDFExporter) savePDFFile(outputPath string, data []byte) error {
	// 这里应该实现文件保存逻辑
	// 为了简化，我们只是模拟保存
	pe.logger.Info("保存PDF文件", map[string]interface{}{
		"path": outputPath,
		"size": len(data),
	})
	return nil
}

// handleExportError 处理导出错误
func (pe *PDFExporter) handleExportError(err error, result *PDFExportResult) {
	result.Success = false
	result.Error = err
	pe.metrics.ExportsFailed++
	
	pe.logger.Error("PDF导出失败", map[string]interface{}{
		"error": err.Error(),
	})
}

// updateMetrics 更新指标
func (pe *PDFExporter) updateMetrics(exportTime time.Duration, fileSize int64, success bool) {
	if success {
		pe.metrics.ExportsSuccess++
	}
	
	pe.metrics.TotalTime += exportTime
	pe.metrics.AverageTime = pe.metrics.TotalTime / time.Duration(pe.metrics.ExportsTotal)
	pe.metrics.LastExportTime = time.Now()
	
	if fileSize > 0 {
		pe.metrics.AverageFileSize = (pe.metrics.AverageFileSize + fileSize) / 2
	}
}

// GetMetrics 获取导出指标
func (pe *PDFExporter) GetMetrics() *PDFExportMetrics {
	pe.mu.RLock()
	defer pe.mu.RUnlock()
	
	return pe.metrics
}

// UpdateConfig 更新配置
func (pe *PDFExporter) UpdateConfig(config *types.PDFExportConfig) {
	pe.mu.Lock()
	defer pe.mu.Unlock()
	
	pe.config = config
}

// GetConfig 获取配置
func (pe *PDFExporter) GetConfig() *types.PDFExportConfig {
	pe.mu.RLock()
	defer pe.mu.RUnlock()
	
	return pe.config
}

// PDFDocumentContent PDF文档内容
type PDFDocumentContent struct {
	Text       string                 `json:"text"`
	Paragraphs []*types.Paragraph     `json:"paragraphs"`
	Tables     []*types.Table         `json:"tables"`
	Images     []types.PDFImageInfo   `json:"images"`
	Metadata   map[string]interface{} `json:"metadata"`
}

// getDefaultPDFConfig 获取默认PDF配置
func getDefaultPDFConfig() *types.PDFExportConfig {
	return &types.PDFExportConfig{
		PageSize:       types.PDFPageSizeA4,
		Orientation:    types.PDFOrientationPortrait,
		Margins:        types.PDFMargins{Top: 72, Bottom: 72, Left: 72, Right: 72},
		Quality:        types.PDFQualityMedium,
		Compression:    true,
		ImageQuality:   80,
		IncludeImages:  true,
		IncludeTables:  true,
		IncludeHeaders: true,
		IncludeFooters: true,
		FontEmbedding:  false,
		DefaultFont:    "Helvetica",
		FontSize:       12,
		Permissions: types.PDFPermissions{
			AllowPrint:    true,
			AllowCopy:     true,
			AllowModify:   false,
			AllowAnnotate: false,
		},
		Creator: "Go Word PDF Exporter",
	}
}